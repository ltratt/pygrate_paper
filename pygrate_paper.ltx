%&pygrate_paper_preamble
\endofdump

\begin{document}
\maketitle

\begin{abstract}
\noindent
Many changes one might wish to make to a programming language break existing
programs, causing disruption and complaint amongst users. Widely used languages
find it increasingly difficult to make such changes, causing them to slowly ossify as
ever more of the language is considered unchangeable.

In this paper, we
consider a notably disruptive change to a mainstream programming language:
the transition from Python 2 to Python 3. We introduce
the idea of \emph{Temporary Migration Variants} (TMV) --- intermediate
language versions which allow
code to be gradually migrated until the TMV is
no longer needed. We implement TMVs for both CPython 2.x and CPython 3.x which
allow code to run with forward/backward compatible fixes and
warnings. Our simple TMVs, though neither complete or perfect, suggest that
it may be possible to keep evolving languages if we provide the ability
for users to gradually migrate their code from one version to another.
\end{abstract}


\section{Introduction}

Programming languages evolve, either to fix existing imperfections, or because
of changes in the wider computing context. However, users -- for whom programming
languages are generally a means rather than an end -- often resist evolution,
either because they worry that the language will become too complicated,
or because their existing programs will no longer run correctly. In this paper
we are motivated by the latter challenge: users often have large, long-lived
codebases that are critical to their purposes and which they must keep running.

Though rarely discussed in the literature, there are many instances in
programming language history of users forcing a language's designers to drop
proposed breaking changes. There are also instances, though harder to quantify,
of languages scaring away potential users after developing a reputation for
frequent breaking changes.

Perhaps surprisingly, there are few automated tools available to assist in
migrating programs between language versions. Some languages ship with tools that can fix some
now-changed idioms (e.g.~Python's \texttt{2to3} tool or Rust's \texttt{cargo
fix}), though these tend only to fix relatively simple syntactic
changes.

Our inability to evolve programs as languages change imposes costs on languages:
some kinds of evolution, though highly desirable, are perceived as too disruptive
for users to be tolerated. Many aspects of languages tend to ossify as a result.

In this paper we introduce the idea of
\emph{Temporary Migration Variants}: throw-away variants of the `old' and `new'
versions of a language which enable smoother migration between the two. As well
as traditional, simple, static warnings of incompatibilities, TMVs aim to
smooth the migration of changes which can only be detected dynamically.
Features can be backwards or forward ported between both versions, warning users of
unsupported, or changed, features while still allowing programs to run. Once
all warnings are fixed, the TMVs have done their job, and can be discarded.

In this paper we show how TMVs can smooth migration in the face of the most
disruptive change to a mainstream language in living memory: the transition
from Python 2 to Python 3. We create two TMVs: \pygratetwo, a variant of
CPython 2.7 which warns when users use features that are missing or
incompatible in Python 3.x, and which backports some features from Python 3.x;
and \pygratethree, a variant of CPython 3.12 which forwards ports some features
from Python 2.x, warning when they are used. In essence, \pygratetwo and
\pygratethree significantly narrow the gap between Python 2 and Python 3: it
means that programs can be kept running during most of the migration process,
though there is still a `gap' between \pygratetwo and \pygratethree. We migrate
several programs, including \emph{Twisted}, an event-driven networking engine
implemented in Python, showing that our TMVs do meaningfully help
migration.

This paper thus serves two purposes: it introduce TMVs and provides a case study
of their use. Although it is important not to over-generalise from a single
example, we believe that \pygratetwo and \pygratethree show that adapting both
the old and new versions of a language meaningfully smoothes migration. This may
prove useful for other languages, including languages very different from
Python, in future migrations. By doing so, this paper makes the following
main contributions:

\begin{itemize}
    \item A technique to allow programs to gradually migrate to a new 
    version of a programming language.
    \item A case study of using this technique to port 
    two real-world Python program namely, Twisted , a popular library based on PyPI downloads.
    \item A discussion of possible outcomes of similar 
    efforts towards automatic migration of Python 2 
    programs to Python 3.
\end{itemize}


\section{The Migration Challenge}

Most readers will probably have experienced the need to adjust one of their
programs after a programming language has evolved. For example, to print a
value to \lstinline{stdout} in Python 2 one could write:

\begin{lstlisting}[language=Python]
print 2+3
\end{lstlisting}

\noindent However, this program fails to compile\footnote{Although often
described as `interpreted' languages, most implementations of languages like
Python first compile programs to another representation (sometimes called
`bytecode') which they then use as a basis for execution.} with Python 3,
reporting a syntax error. Python 2 has a \lstinline{print} statement built-in
to the language's grammar: Python 3 has no such construct in the grammar.
Instead a global \lstinline{print} function is provided, which must be called
using normal function call notation:

\begin{lstlisting}[language=Python]
print(2+3)
\end{lstlisting}

Since \lstinline{print} statements in Python 2 are common, fixing all of
them when migrating to Python 3 may appear tiresome. Fortunately, because
\lstinline{print} is a grammar-level construct in Python 2, all instances
that need fixing can be easily identified. Python 3 comes with a tool called
\lstinline{2to3} which can be statically run over a Python codebase, and not
only point out each \lstinline{print} statement which needs fixing, but
(with the `\lstinline{-w}' flag) update the user's source code too.

Unfortunately, not all such changes between Python 2 and Python 3 are
handled quite so easily. Consider this Python 2 fragment:

\begin{lstlisting}[language=Python]
x = cmp(2, 3)
\end{lstlisting}

The global \lstinline{cmp(x, y)} function in Python 2 compares its two arguments
and returns -1 if $x < y$, 0 if $x = y$, or 1 if $x > y$ --- in this example,
\lstinline{x} will be assigned the value -1. \lstinline{cmp} is
often used as the basis for determining the order to sort collections such
as lists.

Python 3 removes the global \lstinline{cmp} function, causing the fragment
above to produce a generic \lstinline{name not defined} error. Unfortunately,
running the \lstinline{2to3} tool over our fragment does not produce a warning,
let alone attempt to automatically fix it. The probable reason for this is that,
unlike \lstinline{print}, it is impossible to statically identify calls to
\lstinline{cmp} with perfect precision. For example, the user can introduce
their own local function called \lstinline{cmp} which overrides the global
function or import a \lstinline{cmp} function from another module. Such examples
seem like they can be statically detected, but it is easy to use Python's
dynamic features to alter namespaces. A deliberately ludicrous, but fully legal,
example shows the extent of this issue:

\begin{lstlisting}[language=Python]
self_mod = __import__(__name__)
setattr(self_mod.__builtins__, input(), "xyz")
print(cmp)
\end{lstlisting}

This example first gets a reference to the current module using a dynamic name
space lookup (line 1). It then uses \lstinline{input} to read a string from the
user at run-time, and creates or alters a global variable of that name,
assigning it the value of \lstinline{xyz} (line 2). Finally, the current value
of the \lstinline{cmp} global variable is printed out (line 3). For all but one
user inputs, this will print \lstinline{<built-in function cmp>} --- but if the
user happens to enter the string \lstinline{cmp} then it will print out
\lstinline{xyz}.

The point of this example is not, to put it mildly, to showcase good programmer
practise, but to show that Python's highly dynamic nature defeats most seemingly
reasonable static analyses. This means that it is impossible in general
to be sure whether any use of the name \lstinline{cmp} references
the `global' \lstinline{cmp} function or not.

The difficulty of deriving a program's dynamic behaviour from a static
examination presents an impossible choice for static migration tools such as
\lstinline{2to3}. In this case, \lstinline{2to3} can either: assume that all
uses of the name \lstinline{cmp} point to the global function, risking false
positives; or assume that it can't tell, all but guaranteeing false negatives.
Neither outcome is desirable, but arguably false positives are worse in this
case, since they would cause the user's source code to be incorrectly changed.
Perhaps for this reason, \lstinline{2to3} (and other similar tools we are
aware of) nearly always err on the side of caution, heavily favouring
false negatives over false positives.

The ease of migrating \lstinline{print}, and the challenges of migrating
\lstinline{cmp}, between Python 2 and Python 3 highlight the fundamental
challenge of language migration. Language designers can make changes (like
\lstinline{print}) that can be statically detected and fixed with little fear
of substantial user complaint. However, changes which can only be detected
dynamically are far more dangerous. This heavily constrains the possible
changes that most language designers will consider plausible. In this paper we
are chiefly concerned with what happens when language designers wish to
consider, or actually carry out, changes to a language which can only be
detected dynamically. Must the burden of migrating programs be placed entirely
on users? Can we help them carry out their migration? If so, what might `help'
look like and to what degree does it actually help?


\section{Program Migration}

User applications and programs can be modified in response to backward incompatible
changes in the language they are implemented in or even the need to migrate the 
implementation to a completely new programming language. In both cases, the common
objectives are teo fold, first to support any new syntax and secondly, to synchronise
semantics.

Migration of programs from one programming language to another is much more invasive,
requiring the extensive use of higher order abstractions like abstract syntax tress (AST)
or parse trees, and non-trivial code transformations. Most of the challenges stem from 
reconciling semantics like static Vs dynamic typing, functional vs non functional etc.,
between the source and target language.

In contrast, when a new version of a programming language introduces backward incompatible
changes, while it is not perfect to conclude in all cases, migration is not as invasive in 
most cases. However, as the Python ecosystem witnessed in the Python 2 to Python 3 case, 
languages can evolve radically in both syntax and semantics leading to technical challenges
relatively equivalent to a new language all together.

In both these cases, migration of affected user appliations requires that either automated
tools or manual interventions identify the new patterns through \emph{pattern analysis}, 
port the program to match the new syntax and semantics through \emph{source code transformations}
and in some cases just \emph{backporting} of patches from the newer version of the language to the
old version that the user program is based on.


\section{Temporary Migration Variants}

To smoothen migration from older to newer languages, \emph{Temporary Migration Variants} are versions
of the old and new language, with warnings to signal and alert of any feature incompatibilities. For Python, 
we modify the Python 2.7 and Python 3.8 versions, with useful warnings, containing both an error message 
and potential fix for each incompatible syntax encountered for the code base, in two variants,  \pygratetwo 
and \pygratethree respectively.

Executing warnings can introduce unwanted overhead for default language settings. To remedy  this behavior, 
we instead introduce optional flags \lstinline{{-2} for the \pygratethree variant and \lstinline{{-3} for 
the \pygratetwo variant. This way the variants do not have to be completely throw-away.

As we describe in the sequel, because of the complexity in incompatibilities between Python 2 and 3, it 
was not possible to cover most of the cases through static analysis of the code. We instead use more 
dynamic methodologies to abate teasing apart and identifying the incompatibility, warning precisely 
with a more specific and relevant fix.

Warnings are generated at all stages of the compilation process, by introspecting mostly higher order 
abstractions, from for example the grammar, the abstract syntax tree, the compiler and the symbol 
table to correctly identify both syntactic and semantic incompatibilities.

\subsection{Design Principle}

The goal of warnings in both  \pygratetwo and \pygratethree  is to give warnings with useful information 
on a like the warning message, fix and line number that the user can then use to adjust their code in 
a realistic way, rather than syntax errors that just fail the code without any useful immediate information.

With these warnings, the assumption is that the user runs all their code under  \pygratetwo, fixing all 
warnings using the provided hints on potential fixes. After which, they can run their code under \pygratethree, 
fixing all warnings again. At which point we hope that they can run their code unchanged in python3.

The general rationale is to by default issue warnings in \pygratetwo for as many cases as is technically 
possible. In some exceptions we decide to move the warnings to \pygratethree under two circumstances: 
The general rationale is to by default issue warnings in \pygratetwo for as many cases as is technically 
possible. In some exceptions we decide to move the warnings to pygrate3 under two circumstances: 1) 
the need for precision and 2) implementation constraints.

Depending on what changed in either syntax or semantics between Python 2 and 3, it is possible 
that warning in \pygratethree will give us an opportunity to warn more accurately, with 
less false positives. This in turn means  less warnings to deal with for the user. For example, 
if a method \lstinline{{M1} in python2 changes its name to \lstinline{{M2} in python3, 
we get more false positives by adding \lstinline{M2} as an alias in \pygratetwo than we do 
adding \lstinline{M1} as an alias in pygrate3. Note that aliasing is the best case scenario. 
However, sometimes we also have to monitor the engineering trade offs of supporting the \lstinline{{M1} 
syntax in pygrate3 for the warning purposes, it may be just impossible for both \lstinline{{M1} and 
\lstinline{{M2} to coexist, case in point strings.

When Python transitioned to Python 3, not only did the syntax and semantics change, but the
Core team also took time to re-organize and clean up the implementation. It is not a black 
and white decision to judge whether all decisions made in \pygratethree are cleaner. 
In general several parts of the code are cleaner, some equally less modular and in general 
other parts introduce complexity.

Modular code is generally easier to accommodate when warning compared to slots. When we have 
to warn for features exposed as slots we have to either look for a version (\pygratetwo or \pygratethree) 
with better modularity or change the implementation to be modular.

\subsection{Warning Anatomy}

Warnings are implemented as custom exceptions in both Python 2 and 3, thereby introducing new exception classes
\lstinline{Py2XWarning} and \lstinline{Py3xWarning} respectively tied to their corresponding flags, instead of 
using a generic \lstinline{Deprecation} type.





\section{Related work}

\subsection{Program Pattern Analysis}

Existing work has pattern languages like TXl~\cite{cordy06txl} and frameworks SCRUPLE~\cite{paulscruple} which
identify certain patterns in the program to be ported, transforming the programs according
to specified transformation rules.

Pattern analysis involves viewing or converting the source code in an intermediate form that
abates pattern identification. the two common cases involve, either converting the program into
a parse tree and feeding the modified parse tree to a compiler of the target language/version
or viewing the source code as a stream of strings~\cite{Kontogianniscodemigration}.

Pattern idenfication for program migration is mostly achieved through pattern matching of the
original source code by matching strings and regular expressions~\cite{Kontogianniscodemigration} 
to identify statements that require modification to the target syntax. Tradititional pattern 
maching can be extended genenerating parametized suffix tree introducing parametized strings 
and pattern matching~\cite{bakerparampatternmatch, Baker1995ParameterizedPMAndBoyer} to for 
example identify duplicates in the code.

The Boyer-Moore-Type algorithm~\cite{fastboyer} have been used to 
perform efficient strings matching by comparing patterns with text identifying patterns 
that can cause a shift rule to be invoked on the text from left to right or vice versa 
before or after comparison to the pattern~\cite{}. The original Boyer-Moore-Type algorithm 
has gone through modifcations producing variations that make it run 
faster~\cite{Baker1995ParameterizedPMAndBoyer, , }.

Patterns can also be identified through hashing algorithms that use finger print computations
to search for any source code changes or similarities between the source and target 
user programs~\cite{fastboyer}.

Patterns can equally be identified by maintaining and browsing a program database of the user 
application, making queries on the code through the database on the files, functions and 
variables~\cite{}.


\subsection{Source Code Transformation}

For large code bases, the main aim of code transformation 
tooling~\cite{guojavatransformations, Kontogianniscodemigration} 
is to make migration of extension modules to a new API a feasible 
alternative, with strong syntactical guarantees. Semantic guarantees
are harder and thorough testing is required to verify the correctness
of the generated code. 

We achieve code transformations through a specification using \emph{rules}, 
in the following format: \\

\lstinline{[pattern : action]} \\

The first part of a rule specification is a pattern in the code. The second corresponds to 
the steps or procedures that must be taken when the first part matches. For example, 
when performing the transformation for a block of code, the operation that manages the 
conversion of a \lstinline{Statement} is invoked. A matching procedure isolates 
the \lstinline{Statement} kind to be transformed and the relevant conversion 
function is invoked.

\subsection{Patch Backporting}

When languages release new versions, it is common to maintain older versions in a branch
for use by programs that can not adopt early to new versions. Interventions either automated
or manual are used to port some critical features like security patches from the new version 
to the old version~\cite{Shariffdeenbackporting}.

Backporting doesnt modfy the user program, instead the language is modified but depending
on the level of compatibility of the ported patch, the program can be modified.


\bibliographystyle{plain}
\bibliography{bib}

\end{document}
