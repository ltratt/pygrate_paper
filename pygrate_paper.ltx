%&pygrate_paper_preamble
\endofdump

\begin{document}
\maketitle

\begin{abstract}
\noindent
Many changes one might wish to make to a programming language break existing
programs, causing disruption and complaint amongst users. Over time, there
is a tendency for ever more of a language to be considered unchangeable,
causing the language to slowly ossify.

In this paper, we
consider a notably disruptive change to a mainstream programming language:
the transition from Python 2 to Python 3. We introduce
the concept of \emph{Temporary Migration Variants} (TMV) --- intermediate
language versions which allow
code to be gradually migrated until the TMV is
no longer needed. We implement TMVs for both CPython 2.x and CPython 3.x which
allow code to run with forward/backward compatible fixes and
warnings. Our simple TMVs, though neither complete or perfect, suggest that
it may be possible to keep languages evolving by providing the ability
for users to gradually migrate their code from one version to another.
\end{abstract}


\section{Introduction}

Programming languages evolve, either to fix existing imperfections, or because
of changes in the wider computing context. However, users -- for whom programming
languages are generally a means rather than an end -- often resist evolution,
either because they worry that the language will become too complicated,
or because their existing programs will no longer run correctly. In this paper
we are motivated by the latter challenge: users often have large, long-lived
codebases that are critical to their purposes and which they must keep running.

Though rarely discussed in the literature, there are many instances in
programming language history of users forcing a language's designers to
reconsider breaking changes. There are also instances, though harder to quantify,
of languages scaring away potential users after developing a reputation for
frequent breaking changes.

Perhaps surprisingly, there are few automated tools available to assist in
migrating programs between language versions. Some languages ship with tools
(e.g.~Python's \texttt{2to3} tool or Rust's \texttt{cargo
fix}) that can fix some changes, though typically only simple syntactic
changes.

Our inability to evolve programs as languages change imposes costs on languages:
some kinds of evolution, though highly desirable, are perceived as too disruptive
for users to be tolerated. Many aspects of languages tend to ossify as a result.

In this paper we introduce the concept of
\emph{Temporary Migration Variants}: variants of the `old' and `new'
versions of a language which enable smoother migration of programs between the two. As well
as traditional compile-time warnings of incompatibilities, TMVs aim to
deal with changes which only affect run-time.
Features can be backwards or forward ported between both versions, warning users of
unsupported, or changed, features while still allowing programs to run. Once
all warnings for a given program are fixed, the TMVs have done their job, and
the user can move wholesale to the `new' version of the language.

\begin{figure}[t]
\begin{center}
  \includegraphics[width=0.8\textwidth]{semantic_gap.pdf}
\end{center}
\caption{This paper's concepts in the context of Python 2 and Python 3. On
the top row we see the status quo: Python 2 and Python 3 have a substantial semantic gap
which users must manually bridge. In other words, they must take a Python 2
program, and repeatedly alter it until it eventually runs correctly under Python 3:
for much of this process the program either cannot run at all, or only runs
briefly before crashing.
On the middle row we have the Platonic ideal of TMVs: variants of Python 2 and
Python 3 that have no semantic gap, and thus allow the smoothest possible migration
between the two. On the bottom row we have the reality of the \pygratetwo and
\pygratethree TMVs: a much smaller, though still perceptible, semantic gap
compared to Python 2 and Python 3. \pygratetwo and \pygratethree make
migrating programs from Python 2 to Python 3 easier, though they cannot remove
remove all sources of migration friction.}
\label{fig:semantic_gap}
\end{figure}

In this paper we show how TMVs can ease \emph{migration friction} in the face of the most
disruptive change to a mainstream language in living memory: the transition
from Python 2 to Python 3. We create two TMVs: \pygratetwo, a variant of
CPython 2.7 which warns when users use features that are missing or
incompatible in Python 3.x, and which backports some features from Python 3.x;
and \pygratethree, a variant of CPython 3.12 which forwards ports some features
from Python 2.x, warning when they are used. In essence, \pygratetwo and
\pygratethree significantly narrow the semantic gap between Python 2 and Python 3: it
means that programs can be kept running during most of the migration process,
though there is still a semantic gap between \pygratetwo and \pygratethree (see
\cref{fig:semantic_gap} for a visualisation of this idea). We migrate
several programs, including \emph{Twisted}, an event-driven networking engine
implemented in Python, showing that our TMVs do meaningfully ease
migration.

This paper thus serves two purposes: it introduces TMVs and provides a case study
of their use. Although we do not want to over-generalise from a single
example, \pygratetwo and \pygratethree suggest that TMVs meaningfully
smooth migration. This concept may prove useful for other languages, including
for languages which are very different from
Python, in future migrations.


\section{The Migration Challenge}

Most readers will probably have experienced the need to adjust one of their
programs after a programming language has evolved. For example, to print a
value to \lstinline{stdout} in Python 2 one could write:

\begin{lstlisting}[language=Python]
print 2+3
\end{lstlisting}

However, this program fails to compile\footnote{Although often
described as `interpreted' languages, most implementations of languages like
Python first compile programs to another representation (sometimes called
`bytecode') which they then use as a basis for execution.} with Python 3,
reporting a syntax error. Python 2 has a \lstinline{print} statement built-in
to the language's grammar: Python 3 has no such construct in the grammar.
Instead a global \lstinline{print} function is provided, which must be called
using normal function call notation:

\begin{lstlisting}[language=Python]
print(2+3)
\end{lstlisting}

Since \lstinline{print} statements in Python 2 are common, fixing all of
them when migrating to Python 3 may appear tiresome. Fortunately, because
\lstinline{print} is a grammar-level construct in Python 2, it is possible
to statically pinpoint each place that needs fixing with 100\% accuracy. Python 3 comes with a tool called
\lstinline{2to3} which takes as input Python source code and reports, or (with
the `\lstinline{-w}' flag) modifies each \lstinline{print} statement which
needs fixing.

Unfortunately, not all such changes between Python 2 and Python 3 are
handled quite so easily. Consider this Python 2 fragment:

\begin{lstlisting}[language=Python]
x = cmp(2, 3)
\end{lstlisting}

The global \lstinline{cmp(x, y)} function in Python 2 compares its two arguments
and returns -1 if $x < y$, 0 if $x = y$, or 1 if $x > y$ --- in this example,
\lstinline{x} will be assigned the value -1. \lstinline{cmp} is
often used as the basis for determining the order to sort collections such
as lists.

Python 3 removes the global \lstinline{cmp} function, causing the fragment
above to produce a generic `\lstinline{name not defined}' error. Unfortunately,
the \lstinline{2to3} tool does not produce a warning when it sees uses of \lstinline{cmp},
let alone attempt to automatically fix them. The probable reason for this is that,
unlike \lstinline{print}, it is impossible to statically identify calls to
\lstinline{cmp} with 100\% accuracy. For example, the user can introduce
their own local function called \lstinline{cmp} which overrides the global
function or import a \lstinline{cmp} function from another module. Such examples
may seem like they can be statically detected, but it is easy to use Python's
dynamic features to alter namespaces. A deliberately ludicrous, but fully legal,
example shows the extent of this issue:

\begin{lstlisting}[language=Python]
self_mod = __import__(__name__)
n = input()
setattr(self_mod.__builtins__, input(), "xyz")
print(cmp)
\end{lstlisting}

This example first gets a reference to the current module using a dynamic name
space lookup (line 1). It then uses \lstinline{input} to read a string from
the user at run-time (line 2). The value of that string is then used to
create, or if it already exists alters, a global variable,
assigning to it the value of \lstinline{xyz} (line 3). Finally, the current value
of the \lstinline{cmp} global variable is printed out (line 4). For all but one
user inputs, this will print \lstinline{<built-in function cmp>} --- but if the
user happens to enter the string \lstinline{cmp} then it will print out
\lstinline{xyz}. The point of this example is not, to put it mildly, to showcase good programmer
practise, but to show that Python's highly dynamic nature defeats most seemingly
reasonable static analyses.

The difficulty of deriving a program's dynamic behaviour from a static
examination presents a difficult choice for static migration tools such as
\lstinline{2to3}. In this case, \lstinline{2to3} can either: assume that all
uses of the name \lstinline{cmp} point to the global function, risking false
positives; or assume that it can't tell, all but guaranteeing false negatives.
Neither outcome is desirable, but arguably false positives are worse,
since they cause the user's source code to be incorrectly changed.
Perhaps for this reason, \lstinline{2to3} (and other similar tools we are
aware of) nearly always err on the side of caution, heavily favouring
false negatives over false positives.

The ease of migrating \lstinline{print}, and the challenges of migrating
\lstinline{cmp}, between Python 2 and Python 3 highlight the fundamental
challenge of language migration. Language designers can make changes (like
\lstinline{print}) that can be statically detected and fixed with little fear
of substantial user complaint. However, changes which can only be detected
dynamically are far more dangerous. This heavily constrains the possible
changes that most language designers will consider plausible.

In this paper we are therefore
chiefly concerned with what happens when language designers wish to
consider, or actually carry out, changes to a language which can only be
detected dynamically. Must the burden of migrating programs be placed entirely
on users or can we help them carry out their migration? If so, what might `help'
look like and to what degree does it actually help?


\section{Temporary Migration Variants}

The underlying problem that motivates our work is that many desirable changes
to a programming language break user programs in ways that can only
reasonably be detected dynamically. Our solution to this problem is the concept
of \emph{Temporary Migration Variants}: implementations of the `old' and `new'
versions of a language which narrow the semantic gap, helping ease the
migration path. As we shall see, this basic concept can come in several flavours,
though we explore only one in depth in this paper.


\subsection{A Semi-Formal Definition of TMVs}

\newcommand{\tmvlone}{$I'\!_1$\xspace}
\newcommand{\tmvltwo}{$I'\!_2$\xspace}

We define a \emph{programming language} (henceforth just `language') $L$ to
have \emph{semantics} that are a combination of the definition of the `core'
language (e.g.~syntax and dynamic execution rules) and its standard libraries.
For a given language $L$ we have an `old' version of the language with
semantics $L_O$ and a `new' version with semantics $L_N$. We have corresponding
\emph{implementations} of each language $I_O$ and $I_N$. We assume that
implementations faithfully implement a language's semantics.

The challenge we address is that an arbitrary program $P$ written for $L_O$ and
which executes correctly on $I_O$ may not be correct for $L_N$ and thus break
when executed on $I_N$. Programs may \emph{break} in three ways: they may fail
compile-time checks (and thus not compile); they may run and \emph{abort}
execution when they try to use a feature that has changed or been removed; or
they may run and \emph{diverge} from the expected execution paths.

TMVs are variants of both a language's semantics and its corresponding
implementation. For example, if our starting point is $L_O$ and $I_O$, then
defining a TMV requires defining new semantics
$L'\!_O$ and a new implementation $I'\!_O$.

For such a TMV to be useful, we expect: at least $I'\!_O$ to extend $I_O$; and
possibly $L'\!_O$ to extend $L_O$. Thus if $P$ is correct for $L_O$ and
executes correctly on $I_O$ we expect it to be correct for $L'\!_O$ and execute
correctly on $I'\!_O$. At a minimum we expect $I'\!_O$ to produce warnings
when features supported in $L_O$ / $L'\!_O$ but not $L_N$ are used. Often more
usefully, $L'\!_O$ may backport language semantics from $L_N$, allowing $P$ to
be altered to access features not available in $L_O$ (note that changing
$L'\!_O$ implicitly requires changing $I'\!_O$). In the latter case, the TMV
implicitly defines an `intermediate' language whose semantics can be informally
thought of as `between' those of $L_O$ and $L_N$. A program $P$ that has been
modified to $P'$ for $L'\!_O$ may no longer be correct for either $L_O$ or
$L_N$, though $P'$ should should break in fewer ways under $L_N$ and $I_N$
than $P$.

Defining a TMV $T_N$ or $L_N$ is similar, though for the TMV to be useful,
$L'\!_N$ must forward port language semantics from $L_O$. Doing so allows
$I'\!_N$ to warn when such features are used.


\section{XYZ}

To smoothen migration from older to newer languages, \emph{Temporary Migration Variants} are versions
of the old and new language, with warnings to signal and alert of any feature incompatibilities. For Python, 
we modify the Python 2.7 and Python 3.8 versions, with useful warnings, containing both an error message 
and potential fix for each incompatible syntax encountered for the code base, in two variants,  \pygratetwo 
and \pygratethree respectively.

Executing warnings can introduce unwanted overhead for default language settings. To remedy  this behavior, 
we instead introduce optional flags \lstinline{{-2} for the \pygratethree variant and \lstinline{{-3} for 
the \pygratetwo variant. This way the variants do not have to be completely throw-away.

As we describe in the sequel, because of the complexity in incompatibilities between Python 2 and 3, it 
was not possible to cover most of the cases through static analysis of the code. We instead use more 
dynamic methodologies to abate teasing apart and identifying the incompatibility, warning precisely 
with a more specific and relevant fix.

Warnings are generated at all stages of the compilation process, by introspecting mostly higher order 
abstractions, from for example the grammar, the abstract syntax tree, the compiler and the symbol 
table to correctly identify both syntactic and semantic incompatibilities.

\subsection{Design Principle}

The goal of warnings in both  \pygratetwo and \pygratethree  is to give warnings with useful information 
on a like the warning message, fix and line number that the user can then use to adjust their code in 
a realistic way, rather than syntax errors that just fail the code without any useful immediate information.

With these warnings, the assumption is that the user runs all their code under  \pygratetwo, fixing all 
warnings using the provided hints on potential fixes. After which, they can run their code under \pygratethree, 
fixing all warnings again. At which point we hope that they can run their code unchanged in python3.

The general rationale is to by default issue warnings in \pygratetwo for as many cases as is technically 
possible. In some exceptions we decide to move the warnings to \pygratethree under two circumstances: 
The general rationale is to by default issue warnings in \pygratetwo for as many cases as is technically 
possible. In some exceptions we decide to move the warnings to pygrate3 under two circumstances: 1) 
the need for precision and 2) implementation constraints.

Depending on what changed in either syntax or semantics between Python 2 and 3, it is possible 
that warning in \pygratethree will give us an opportunity to warn more accurately, with 
less false positives. This in turn means  less warnings to deal with for the user. For example, 
if a method \lstinline{{M1} in python2 changes its name to \lstinline{{M2} in python3, 
we get more false positives by adding \lstinline{M2} as an alias in \pygratetwo than we do 
adding \lstinline{M1} as an alias in pygrate3. Note that aliasing is the best case scenario. 
However, sometimes we also have to monitor the engineering trade offs of supporting the \lstinline{{M1} 
syntax in pygrate3 for the warning purposes, it may be just impossible for both \lstinline{{M1} and 
\lstinline{{M2} to coexist, case in point strings.

When Python transitioned to Python 3, not only did the syntax and semantics change, but the
Core team also took time to re-organize and clean up the implementation. It is not a black 
and white decision to judge whether all decisions made in \pygratethree are cleaner. 
In general several parts of the code are cleaner, some equally less modular and in general 
other parts introduce complexity.

Modular code is generally easier to accommodate when warning compared to slots. When we have 
to warn for features exposed as slots we have to either look for a version (\pygratetwo or \pygratethree) 
with better modularity or change the implementation to be modular.

\subsection{Warning Anatomy}

Warnings are implemented as custom exceptions in both Python 2 and 3, thereby introducing new exception classes
\lstinline{Py2XWarning} and \lstinline{Py3xWarning} respectively tied to their corresponding flags, instead of 
using a generic \lstinline{Deprecation} type.

\joannah{This is a big one, I have clipped to hint where I have reached but I am still writing the remaining section
and dont feel like commmiting what I have, its likely to change}



\section{Related work}

\subsection{Program Pattern Analysis}

Existing work has pattern languages like TXl~\cite{cordy06txl} and frameworks SCRUPLE~\cite{paul94framework} which
identify certain patterns in the program to be ported, transforming the programs according
to specified transformation rules.

Pattern analysis involves viewing or converting the source code in an intermediate form that
abates pattern identification. the two common cases involve, either converting the program into
a parse tree and feeding the modified parse tree to a compiler of the target language/version
or viewing the source code as a stream of strings~\cite{kontogiannis10code}.

Pattern idenfication for program migration is mostly achieved through pattern matching of the
original source code by matching strings and regular expressions~\cite{kontogiannis10code} 
to identify statements that require modification to the target syntax. Tradititional pattern 
maching can be extended genenerating parametized suffix tree introducing parametized strings 
and pattern matching~\cite{baker93theory, baker95parameterized} to for 
example identify duplicates in the code.

The Boyer-Moore-Type algorithm~\cite{watson03boyer} have been used to 
perform efficient strings matching by comparing patterns with text identifying patterns 
that can cause a shift rule to be invoked on the text from left to right or vice versa 
before or after comparison to the pattern~\cite{baker95parameterized}. The original 
Boyer-Moore-Type algorithm has gone through modifcations producing variations that make it run 
faster~\cite{baker95parameterized, watson03boyer, waga16boyer}.

Patterns can also be identified through hashing algorithms that use finger print computations
to search for any source code changes or similarities between the source and target 
user programs~\cite{watson03boyer}.

Patterns can equally be identified by maintaining and browsing a program database of the user 
application, making queries on the code through the database on the files, functions and 
variables~\cite{paul94framework}.


\subsection{Source Code Transformation}

For large code bases, the main aim of code transformation 
tooling~\cite{guo03unique, kontogiannis10code} 
is to make migration of extension modules to a new API a feasible 
alternative, with strong syntactical guarantees. Semantic guarantees
are harder and thorough testing is required to verify the correctness
of the generated code. 

We achieve code transformations through a specification using \emph{rules}, 
in the following format: 

\lstinline{[pattern : action]} 

The first part of a rule specification is a pattern in the code. The second corresponds to 
the steps or procedures that must be taken when the first part matches. For example, 
when performing the transformation for a block of code, the operation that manages the 
conversion of a \lstinline{Statement} is invoked. A matching procedure isolates 
the \lstinline{Statement} kind to be transformed and the relevant conversion 
function is invoked.

\subsection{Patch Backporting}

When languages release new versions, it is common to maintain older versions in a branch
for use by programs that can not adopt early to new versions. Interventions either automated
or manual are used to port some critical features like security patches from the new version 
to the old version~\cite{shariffdeen21automated}.

Backporting doesnt modfy the user program, instead the language is modified but depending
on the level of compatibility of the ported patch, the program can be modified.


\bibliographystyle{plain}
\bibliography{bib}

\end{document}
